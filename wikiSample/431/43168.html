<html><title>C++</title><body>&#10;<p> &#10;<b>C++</b> (em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_portuguesa" id="w">portugu&ecirc;s</a> l&ecirc;&shy;se &#34&semi;c&ecirc; mais mais&#34&semi;, em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a> l&ecirc;&shy;se <i>see plus plus</i>) &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">multi&shy;paradigma</a> e de uso geral. A linguagem &eacute; considerada de m&eacute;dio n&iacute;vel, pois combina caracter&iacute;sticas de linguagens de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">alto</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">baixo</a> n&iacute;veis. Desde os <a href="http://en.wikipedia.org/wiki/Anos_1990" id="w">anos 1990</a> &eacute; uma das linguagens comerciais mais populares, sendo bastante usada tamb&eacute;m na <a href="http://en.wikipedia.org/wiki/Academia" id="w">academia</a> por seu grande desempenho e base de utilizadores.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup" id="w">Bjarne Stroustrup</a> desenvolveu o C++ (originalmente com o nome <i>C with <a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">Classes</a></i>,<sup id="_ref&shy;entrevista A&shy;Z_a" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> que significa <i>C com <a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">classes</a></i> em portugu&ecirc;s) em <a href="http://en.wikipedia.org/wiki/1983" id="w">1983</a> no <a href="http://en.wikipedia.org/wiki/Bell_Labs" id="w">Bell Labs</a> como um adicional &agrave; linguagem <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>. Novas caracter&iacute;sticas foram adicionadas com o tempo, como fun&ccedil;&otilde;es virtuais, sobrecarga de <a href="http://en.wikipedia.org/wiki/Operador" id="w">operadores</a>, <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a_m%C3%BAltipla" id="w">heran&ccedil;a m&uacute;ltipla</a>, gabaritos e <a href="http://en.wikipedia.org/wiki/Tratamento_de_exce%C3%A7%C3%B5es" id="w">tratamento de exce&ccedil;&otilde;es</a>. Ap&oacute;s a padroniza&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Organiza%C3%A7%C3%A3o_Internacional_para_Padroniza%C3%A7%C3%A3o" id="w">ISO</a> realizada em <a href="http://en.wikipedia.org/wiki/1998" id="w">1998</a> e a posterior revis&atilde;o realizada em <a href="http://en.wikipedia.org/wiki/2003" id="w">2003</a>, uma nova vers&atilde;o da especifica&ccedil;&atilde;o da linguagem foi lan&ccedil;ada em setembro de <a href="http://en.wikipedia.org/wiki/2011" id="w">2011</a>, conhecida informalmente como <a href="http://en.wikipedia.org/wiki/C%2B%2B11" id="w">C++11</a> ou <i>C++0x</i>.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup></p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<a id="A_evolu%C3%A7%C3%A3o_da_linguagem" name="A_evolu%C3%A7%C3%A3o_da_linguagem"></a><h3> A evolu&ccedil;&atilde;o da linguagem </h3>&#10;<p>O C++ foi inicialmente desenvolvido por Bjarne Stroustrup dos Bell Labs, durante a <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1980" id="w">d&eacute;cada de 1980</a> com o objetivo implementar uma vers&atilde;o distribu&iacute;da do <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_(inform%C3%A1tica)" id="w">n&uacute;cleo</a> <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>.<sup id="_ref&shy;entrevista A&shy;Z_b" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> Como o Unix era escrito em <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>, dever&shy;se&shy;ia manter a compatibilidade, ainda que adicionando novos recursos. Alguns dos desafios inclu&iacute;am simular a infraestrutura da <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a> num <a href="http://en.wikipedia.org/wiki/Sistema_distribu%C3%ADdo" id="w">sistema distribu&iacute;do</a> ou de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_compartilhada" id="w">mem&oacute;ria compartilhada</a> e escrever <i><a href="http://en.wikipedia.org/wiki/Driver_de_dispositivo" id="w">drivers</a></i> para tal sistema. Stroustrup percebeu que a linguagem <a href="http://en.wikipedia.org/wiki/Simula_67" id="w">Simula 67</a> possu&iacute;a caracter&iacute;sticas bastante &uacute;teis para o <a href="http://en.wikipedia.org/wiki/Desenvolvimento_de_software" id="w">desenvolvimento de software</a>, mas que era muito lenta para uso pr&aacute;tico. Por outro lado, a linguagem <a href="http://en.wikipedia.org/wiki/BCPL" id="w">BCPL</a> era r&aacute;pida, mas possu&iacute;a demasiado <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">baixo n&iacute;vel</a>, dificultando sua utiliza&ccedil;&atilde;o no desenvolvimento de <a href="http://en.wikipedia.org/wiki/Software_aplicativo" id="w">aplica&ccedil;&otilde;es</a>. A partir de sua experi&ecirc;ncia de <a href="http://en.wikipedia.org/wiki/Doutoramento" id="w">doutorado</a>, come&ccedil;ou a acrescentar elementos do Simula 67 no C, especialmente os recursos de cria&ccedil;&atilde;o e manipula&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Objeto_(inform%C3%A1tica)" id="w">objetos</a>. O C foi escolhido como base de desenvolvimento da nova linguagem pois possu&iacute;a uma proposta de uso gen&eacute;rico, era r&aacute;pido e tamb&eacute;m <a href="http://en.wikipedia.org/wiki/Software_aplicativo" id="w">port&aacute;vel</a> para diversas <a href="http://en.wikipedia.org/wiki/Plataforma_(inform%C3%A1tica)" id="w">plataformas</a>. Algumas outras linguagens que tamb&eacute;m serviram de inspira&ccedil;&atilde;o para o <a href="http://en.wikipedia.org/wiki/Cientista_da_computa%C3%A7%C3%A3o" id="w">cientista da computa&ccedil;&atilde;o</a> foram <a href="http://en.wikipedia.org/wiki/ALGOL_68" id="w">ALGOL 68</a>, <a href="http://en.wikipedia.org/wiki/Ada_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ada</a>, <a href="http://en.wikipedia.org/wiki/CLU_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">CLU</a> e <a href="http://en.wikipedia.org/wiki/ML_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">ML</a>.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Stroustrup_kent_state_edit.jpg%7Cthumb%7Cright%7C150px" id="w">[[Bjarne Stroustrup]] em [[2007]]</a>&#10;Ainda em <a href="http://en.wikipedia.org/wiki/1983" id="w">1983</a> o nome da linguagem foi alterado de <i>C with Classes</i> para C++. Antes implementada usando um <a href="http://en.wikipedia.org/wiki/Pr%C3%A9&shy;processador" id="w">pr&eacute;&shy;processador</a>, a linguagem passou a exigir um compilador pr&oacute;prio, escrito pelo pr&oacute;prio Stroustrup.<sup id="_ref&shy;entrevista A&shy;Z_c" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> Novas caracter&iacute;sticas foram adicionadas, como fun&ccedil;&otilde;es virtuais,<sup id="_ref&shy;entrevista A&shy;Z_d" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> sobrecarga de <a href="http://en.wikipedia.org/wiki/Operador" id="w">operadores</a> e fun&ccedil;&otilde;es,<sup id="_ref&shy;entrevista A&shy;Z_e" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> <a href="http://en.wikipedia.org/wiki/Refer%C3%AAncia_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">refer&ecirc;ncias</a>, <a href="http://en.wikipedia.org/wiki/Constante_(programa%C3%A7%C3%A3o)" id="w">constantes</a>, <a href="http://en.wikipedia.org/wiki/Gerenciamento_de_mem%C3%B3ria" id="w">gerenciamento manual de mem&oacute;ria</a>, melhorias na verifica&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipo de dado</a> e estilo de coment&aacute;rio de c&oacute;digo de uma linha (<code>//</code>). Em <a href="http://en.wikipedia.org/wiki/1985" id="w">1985</a> foi lan&ccedil;ada a primeira edi&ccedil;&atilde;o do livro <i>The C++ Programming Language</i>, contendo refer&ecirc;ncias para a utiliza&ccedil;&atilde;o da linguagem, j&aacute; que ainda n&atilde;o era uma norma oficial. A primeira vers&atilde;o comercial foi lan&ccedil;ada em outubro do mesmo ano.<sup id="_ref&shy;inven&ccedil;&atilde;o_a" class="reference"><a href="#_note&shy;inven&ccedil;&atilde;o" title="">[5]</a></sup> Em <a href="http://en.wikipedia.org/wiki/1989" id="w">1989</a> a segunda vers&atilde;o foi lan&ccedil;ada, contendo novas caracter&iacute;sticas como <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a_m%C3%BAltipla" id="w">heran&ccedil;a m&uacute;ltipla</a>, classes abstratas, m&eacute;todos est&aacute;ticos, m&eacute;todos constantes e membros protegidos, incrementando o suporte a orienta&ccedil;&atilde;o a objeto. Em <a href="http://en.wikipedia.org/wiki/1990" id="w">1990</a> foi lan&ccedil;ado o livro <i>The Annotated C++ Reference Manual</i>, que tornou&shy;se base para o futuro padr&atilde;o. Outras adi&ccedil;&otilde;es na linguagem incluem gabaritos, tratamento de exce&ccedil;&otilde;es, <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_nomes" id="w">espa&ccedil;o de nomes</a>, convers&atilde;o segura de tipo de dado e o tipo <a href="http://en.wikipedia.org/wiki/Booleano" id="w">booleano</a>.</p>&#10;<p>Assim como a linguagem, sua <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">biblioteca padr&atilde;o</a> tamb&eacute;m sofreu melhorias ao longo do tempo. Sua primeira adi&ccedil;&atilde;o foi a biblioteca de <a href="http://en.wikipedia.org/wiki/E/S" id="w">E/S</a>, e posteriormente a <i><a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">Standard Template Library</a></i> (STL)&semi; ambas tornaram&shy;se algumas das principais funcionalidades que distanciaram a linguagem em rela&ccedil;&atilde;o a C. Criada primordialmente na <a href="http://en.wikipedia.org/wiki/Hewlett&shy;Packard" id="w">HP</a> por <a href="http://en.wikipedia.org/wiki/Alexander_Stepanov" id="w">Alexander Stepanov</a><sup id="_ref&shy;STL_a" class="reference"><a href="#_note&shy;STL" title="">[6]</a></sup> no in&iacute;cio da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1990" id="w">d&eacute;cada de 1990</a> para explorar os potenciais da programa&ccedil;&atilde;o gen&eacute;rica, a STL foi apresentada a um comit&ecirc; unificado <a href="http://en.wikipedia.org/wiki/ANSI" id="w">ANSI</a> e <a href="http://en.wikipedia.org/wiki/ISO" id="w">ISO</a> em <a href="http://en.wikipedia.org/wiki/1993" id="w">1993</a> &agrave; convite de <a href="http://en.wikipedia.org/wiki/En:Andrew_Koenig_(programmer)" id="w">Andrew Koenig</a>. Ap&oacute;s uma proposta formal na reuni&atilde;o do ano seguinte, a biblioteca recebe o aval do comit&ecirc;.</p>&#10;<p>Depois de anos de trabalho, o mesmo comit&ecirc; ANSI/ISO padronizou o C++ em <a href="http://en.wikipedia.org/wiki/1998" id="w">1998</a> (<i><a href="http://en.wikipedia.org/wiki/ISO/IEC_14882" id="w">ISO/IEC 14882</a>:1998</i>). Ap&oacute;s alguns anos foram reportados defeitos e imprecis&otilde;es no documento, e uma corre&ccedil;&atilde;o foi lan&ccedil;ada em <a href="http://en.wikipedia.org/wiki/2003" id="w">2003</a>.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup></p>&#10;<p>Por muito tempo, o C++ foi encarado como um superconjunto do C.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup> Entretanto, em <a href="http://en.wikipedia.org/wiki/1999" id="w">1999</a> o novo padr&atilde;o ISO para a linguagem C tornou as duas linguagens ainda mais diferentes entre si. Devido a essas incompatibilidades, muitas empresas que desenvolvem <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a> n&atilde;o oferecem suporte &agrave; vers&atilde;o mais recente da linguagem C.</p>&#10;<p>Pode&shy;se dizer que C++ foi a &uacute;nica linguagem entre tantas outras que obteve sucesso como uma sucessora &agrave; linguagem C, inclusive servindo de inspira&ccedil;&atilde;o para outras linguagens como <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_Java" id="w">Java</a>, a <a href="http://en.wikipedia.org/wiki/Linguagem_de_descri%C3%A7%C3%A3o_de_interface" id="w">IDL</a> de <a href="http://en.wikipedia.org/wiki/CORBA" id="w">CORBA</a> e <a href="http://en.wikipedia.org/wiki/C%E2%99%AF" id="w">C&#9839;</a>.</p>&#10;<a id="Etimologia" name="Etimologia"></a><h3> Etimologia </h3>&#10;<p>Durante sua fase inicial de desenvolvimento, a linguagem era chamada &#34&semi;novo C&#34&semi;, &#34&semi;C84&#34&semi; ou ainda &#34&semi;C com classes&#34&semi;.<sup id="_ref&shy;entrevista A&shy;Z_f" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> O termo &#34&semi;C++&#34&semi; &eacute; creditado a Rick Mascitti,<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup> e foi utilizado pela primeira vez em dezembro de <a href="http://en.wikipedia.org/wiki/1983" id="w">1983</a>. Ele &eacute; uma refer&ecirc;ncia ao <a href="http://en.wikipedia.org/wiki/Operador" id="w">operador</a> de incremento <code>++</code>, significando um acr&eacute;scimo (uma evolu&ccedil;&atilde;o) &agrave; linguagem C. Em tom humorado, desenvolvedores software e especialistas em <a href="http://en.wikipedia.org/wiki/Inform%C3%A1tica" id="w">inform&aacute;tica</a> no in&iacute;cio da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1990" id="w">d&eacute;cada de 1990</a> costumavam relacionar o ++ do nome &agrave; grande insist&ecirc;ncia dos programadores em utilizar o C++ da mesma forma que a linguagem C, n&atilde;o usufruindo das novas facilidades que a linguagem poderia fornecer. Assim como o ++ estava sendo aplicado de maneira p&oacute;s&shy;fixa &agrave; letra <i>C</i>, a linguagem C++ era uma evolu&ccedil;&atilde;o do C p&oacute;s&shy;fixada, que s&oacute; tornar&shy;se&shy;ia realidade em algum futuro remoto, n&atilde;o naquele momento.</p>&#10;<a id="Trabalhos_futuros" name="Trabalhos_futuros"></a><h3> Trabalhos futuros </h3>&#10;<p>A linguagem continua evoluindo de forma a fornecer novas funcionalidades. O grupo de desenvolvimento <a href="http://en.wikipedia.org/wiki/Biblioteca_Boost" id="w">Boost.org</a> trabalha para evoluir a biblioteca padr&atilde;o, informando o comit&ecirc; oficial da linguagem quais facilidades possuem maior retorno positivo dos usu&aacute;rios, seja por qualidade ou por utilidade, e quais ainda devem ser desenvolvidas. Tudo indica que o C++ continuar&aacute; com sua natureza <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">multiparadigma</a>. Por exemplo, o trabalho da Boost.org dedica&shy;se a acrescentar as qualidades da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a> e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_gen%C3%A9rica" id="w">gen&eacute;rica</a>. O padr&atilde;o C++ n&atilde;o define a implementa&ccedil;&atilde;o para a defini&ccedil;&atilde;o de nomes e tratamento de exce&ccedil;&otilde;es, entre outras facilidades espec&iacute;ficas, o que frequentemente torna incompat&iacute;veis <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_objeto" id="w">c&oacute;digos objeto</a> produzidos por diferentes <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a>. Apesar disso, existem padr&otilde;es perif&eacute;ricos espec&iacute;ficos para certas plataformas ou <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistemas operacionais</a> para padronizar compiladores dessas plataformas, como por exemplo o C++ ABI.<sup id="_ref&shy;10" class="reference"><a href="#_note&shy;10" title="">[10]</a></sup></p>&#10;<p>As empresas de desenvolvimento de compiladores ainda se esfor&ccedil;am para suportar inteiramente o padr&atilde;o, especialmente na &aacute;rea de gabaritos. Uma das disputas se refere &agrave; <a href="http://en.wikipedia.org/wiki/Palavra_reservada" id="w">palavra reservada</a> <code>export</code>, que permite que a defini&ccedil;&atilde;o de um gabarito seja separada de sua declara&ccedil;&atilde;o. O primeiro compilador a implementar <code>export</code> foi o <a href="http://en.wikipedia.org/wiki/Comeau_C%2B%2B" id="w">Comeau C++</a> em <a href="http://en.wikipedia.org/wiki/2003" id="w">2003</a> (cinco anos ap&oacute;s o lan&ccedil;amento do padr&atilde;o), e no ano seguinte uma <a href="http://en.wikipedia.org/wiki/Vers%C3%A3o_beta" id="w">vers&atilde;o beta</a> do <a href="http://en.wikipedia.org/wiki/Borland_C%2B%2B_Builder" id="w">Borland C++ Builder</a> X tamb&eacute;m suportava a facilidade. Interessante notar que ambos os compiladores s&atilde;o baseados na vers&atilde;o EDG do C++. Muitos livros fornecem exemplos de c&oacute;digos para implementar <code>export</code><sup id="_ref&shy;11" class="reference"><a href="#_note&shy;11" title="">[11]</a></sup> que n&atilde;o s&atilde;o compil&aacute;veis, mas n&atilde;o h&aacute; refer&ecirc;ncias para o problema mencionado. Outros compiladores como o <a href="http://en.wikipedia.org/wiki/Visual_C%2B%2B" id="w">Microsoft Visual C++</a> e o <a href="http://en.wikipedia.org/wiki/GCC" id="w">GCC</a> n&atilde;o suportam a facilidade. O secret&aacute;rio do comit&ecirc; oficial do C++ <a href="http://en.wikipedia.org/wiki/Herb_Sutter" id="w">Herb Sutter</a> recomendou que a palavra fosse removida de vers&otilde;es futuras do padr&atilde;o da linguagem,<sup id="_ref&shy;12" class="reference"><a href="#_note&shy;12" title="">[12]</a></sup> mas ap&oacute;s discuss&atilde;o a decis&atilde;o final foi mant&ecirc;&shy;la.<sup id="_ref&shy;13" class="reference"><a href="#_note&shy;13" title="">[13]</a></sup></p>&#10;<p>Outras disputas relativas a gabaritos se referem &agrave; especializa&ccedil;&atilde;o parcial, que foi pouco suportada por muitos anos depois que o C++ padr&atilde;o foi lan&ccedil;ado.</p>&#10;<p>Atualmente a linguagem tem uma nova especifica&ccedil;&atilde;o, conhecida por <a href="http://en.wikipedia.org/wiki/C%2B%2B11" id="w">C++11</a> e publicada como 14882:2011.<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup></p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<a id="Hist%C3%B3ria_descritiva" name="Hist%C3%B3ria_descritiva"></a><h3> Hist&oacute;ria descritiva </h3>&#10;<p>No livro <i>In The Design and Evolution of C++</i> (<a href="http://en.wikipedia.org/wiki/1994" id="w">1994</a>), Bjarne Stroustrup descreve algumas regras que ele utiliza para desenvolver a linguagem, como exemplificado abaixo:</p>&#10;&#10;<ul>&#10;<li>C++ &eacute; desenvolvido para ser uma <a href="http://en.wikipedia.org/wiki/Linguagem_tipada" id="w">linguagem tipada</a> estaticamente e de prop&oacute;sito geral que &eacute; t&atilde;o eficiente e port&aacute;til quanto o C.</li>&#10;<li>C++ &eacute; desenvolvido para suportar m&uacute;ltiplos <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">paradigmas</a>.</li>&#10;<li>C++ &eacute; desenvolvido para fornecer ao programador escolhas, mesmo que seja poss&iacute;vel ao programador escolher a op&ccedil;&atilde;o errada.</li>&#10;<li>C++ &eacute; desenvolvido para ser o mais compat&iacute;vel com C poss&iacute;vel, fornecendo transi&ccedil;&otilde;es simples para c&oacute;digo C.</li>&#10;<li>C++ evita fornecer facilidades que s&atilde;o espec&iacute;ficas a certas plataformas ou a certos grupos de desenvolvedores.</li>&#10;<li>C++ n&atilde;o exige <i><a href="http://en.wikipedia.org/wiki/Overhead" id="w">overhead</a></i> para facilidades que n&atilde;o s&atilde;o utilizadas.</li>&#10;<li>C++ &eacute; desenvolvido para ser utilizado mesmo sem um ambiente de desenvolvimento sofisticado.</li></ul>&#10;<p>Stanley B. Lippman documenta em seu livro <i>Inside the C++ Object Model</i> (<a href="http://en.wikipedia.org/wiki/1996" id="w">1996</a>)<sup id="_ref&shy;15" class="reference"><a href="#_note&shy;15" title="">[15]</a></sup> como <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a> convertem c&oacute;digo de programas C++ em mapeamentos de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">mem&oacute;ria</a>. Lippman trabalhou implementando e mantendo o C&shy;front, a implementa&ccedil;&atilde;o original do C++ nos <a href="http://en.wikipedia.org/wiki/Bell_Labs" id="w">Bell Labs</a>.</p>&#10;<p>Stroustrup sempre desejou que o C++ fosse mantido como uma linguagem de especifica&ccedil;&atilde;o pequena, apesar de press&otilde;es externas para adi&ccedil;&otilde;es de novas funcionalidades na especifica&ccedil;&atilde;o da pr&oacute;pria linguagem ao inv&eacute;s da codifica&ccedil;&atilde;o de novas bibliotecas para a biblioteca padr&atilde;o. <a href="http://en.wikipedia.org/wiki/Brian_Kernighan" id="w">Brian Kernighan</a> notou que enquanto em C existe geralmente uma maneira de resolver problemas, em C++ existem v&aacute;rias. Na maioria das linguagens de programa&ccedil;&atilde;o, um padr&atilde;o ou um conjunto bastante restrito de <a href="http://en.wikipedia.org/wiki/Padr%C3%B5es_de_projeto_de_software" id="w">padr&otilde;es de projeto de software</a> &eacute; escolhido para o desenvolvimento. Entretanto, isso n&atilde;o acontece em C++, pois a escolha &eacute; delegada ao desenvolvedor. &Eacute; um conceito que prega que n&atilde;o existe <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">paradigma de programa&ccedil;&atilde;o</a> ou padr&atilde;o de desenvolvimento que resolva todos os problemas, por isso a pluralidade e generalidade de aplica&ccedil;&otilde;es para a linguagem. Tal filosofia assusta iniciantes e professores, que sentem que a linguagem deveria ser de f&aacute;cil aprendizado, algo que o C++ n&atilde;o &eacute;.</p>&#10;<a id="Biblioteca_padr%C3%A3o" name="Biblioteca_padr%C3%A3o"></a><h3> Biblioteca padr&atilde;o </h3>&#10;<p> &#10; &#10;A biblioteca padr&atilde;o do C++ incorpora a biblioteca padr&atilde;o do C com algumas pequenas modifica&ccedil;&otilde;es para trabalhar melhor com as novas funcionalidades criadas pela linguagem. Outra grande parte da biblioteca &eacute; composta pela biblioteca padr&atilde;o de gabaritos (<a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">STL</a>). Ela fornece ferramentas &uacute;teis como <i><a href="http://en.wikipedia.org/wiki/Container" id="w">containers</a></i> (<a href="http://en.wikipedia.org/wiki/Vetor" id="w">vetores</a>, <a href="http://en.wikipedia.org/wiki/Lista_encadeada" id="w">listas</a>, entre outros), <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> (filtragem de elementos de <i>container</i>, <a href="http://en.wikipedia.org/wiki/Algoritmo_de_busca" id="w">busca</a>, <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_(computa%C3%A7%C3%A3o)" id="w">ordena&ccedil;&atilde;o</a>, entre outros) e <a href="http://en.wikipedia.org/wiki/Iterador" id="w">iteradores</a> (<a href="http://en.wikipedia.org/wiki/Ponteiro_inteligente" id="w">ponteiros inteligentes</a> gen&eacute;ricos para acessar tais <i>containers</i> e interlig&aacute;&shy;los aos algoritmos). Usando gabaritos &eacute; poss&iacute;vel escrever <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_gen%C3%A9rica" id="w">algoritmos gen&eacute;ricos</a> que funcionam para qualquer <i>container</i> ou sequ&ecirc;ncia definida por iteradores. Tendo em vista que um iterador nada mais &eacute; que um <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiro</a> <a href="http://en.wikipedia.org/wiki/Encapsulamento" id="w">encapsulado</a>, &eacute; poss&iacute;vel tamb&eacute;m utilizar os algoritmos gen&eacute;ricos em vetores C, utilizando&shy;se ponteiros comuns para tal. Como em C, os m&oacute;dulos da biblioteca s&atilde;o acessadas utilizando a diretiva <code>#include</code>&semi; ao todo s&atilde;o fornecidos 69 cabe&ccedil;alhos&shy;padr&atilde;o, dos quais 19 est&atilde;o em deprecia&ccedil;&atilde;o.</p>&#10;<p>Devido ao fato da biblioteca padr&atilde;o ter sido desenvolvida por especialistas e de j&aacute; ter sido amplamente utilizada comercialmente e academicamente, &eacute; recomendado utilizar seus componentes ao inv&eacute;s de componentes pr&oacute;prios. Por exemplo, utilizar <code>std::vector</code> e <code>std::string</code> ao inv&eacute;s de declarar vetores herdados do C n&atilde;o somente torna o <a href="http://en.wikipedia.org/wiki/Desenvolvimento_de_software" id="w">desenvolvimento</a> mais simples, como tamb&eacute;m traz mais <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_da_informa%C3%A7%C3%A3o" id="w">seguran&ccedil;a</a> e <a href="http://en.wikipedia.org/wiki/Escalabilidade" id="w">escalabilidade</a> para o sistema.</p>&#10;<p>A biblioteca STL foi originalmente desenvolvida pela <a href="http://en.wikipedia.org/wiki/Hewlett&shy;Packard" id="w">HP</a><sup id="_ref&shy;STL_b" class="reference"><a href="#_note&shy;STL" title="">[6]</a></sup> e posteriormente pela <a href="http://en.wikipedia.org/wiki/SGI" id="w">SGI</a>, antes de sua incorpora&ccedil;&atilde;o na biblioteca padr&atilde;o do C++. O padr&atilde;o n&atilde;o a define como &#34&semi;STL&#34&semi;, mas ainda utiliza&shy;se esse termo para distingui&shy;la do resto da biblioteca. O projeto STLPort mant&eacute;m uma implementa&ccedil;&atilde;o atualizada da biblioteca, e &eacute; baseado na SGI STL. O <a href="http://en.wikipedia.org/wiki/Biblioteca_Boost" id="w">projeto Boost</a> fornece elementos adicionais &agrave; STL, dos quais alguns j&aacute; s&atilde;o considerados a serem parte da biblioteca padr&atilde;o no futuro.</p>&#10;<a id="Operadores" name="Operadores"></a><h3> Operadores </h3>&#10;<p> &#10;Os <a href="http://en.wikipedia.org/wiki/Operador" id="w">operadores</a> em C++ s&atilde;o um conjunto de todos os operadores do C mais novas adi&ccedil;&otilde;es &agrave; linguagem. Um grupo de novos operadores do C++ s&atilde;o os relativos &agrave; convers&atilde;o de <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipo de dado</a>, e consistem em <code>const_cast</code>, <code>static_cast</code>, <code>dynamic_cast</code> e <code>reinterpret_cast</code>. Eles s&atilde;o uma evolu&ccedil;&atilde;o a convers&atilde;o de dados utilizada em C, que limitava&shy;se a oferecer um m&eacute;todo para convers&atilde;o tal qual <code>static_cast</code>. <code>dynamic_cast</code> refere&shy;se diretamente ao suporte de <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a" id="w">heran&ccedil;a</a> e <a href="http://en.wikipedia.org/wiki/Polimorfismo" id="w">polimorfismo</a> oferecido pela linguagem, e est&aacute; relacionado a outro novo operador, <code>typeid</code>, que retorna informa&ccedil;&otilde;es sobre o tipo de dado derivado pelo operando. Ambos os operadores requerem a habilita&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/RTTI" id="w">RTTI</a> para funcionar. Outro grupo de novos operadores s&atilde;o os relativos &agrave; aloca&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">mem&oacute;ria</a>, e consistem em <code>new</code> e <code>delete</code>. Assemelham&shy;se &agrave;s fun&ccedil;&otilde;es <code>malloc</code> e <code>free</code> respectivamente, que est&atilde;o presentes na biblioteca padr&atilde;o do C. Outro novo operador &eacute; o de resolu&ccedil;&atilde;o de &acirc;mbito, <code>::</code>, e que refere&shy;se diretamente ao suporte de <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_nomes" id="w">espa&ccedil;o de nomes</a> e orienta&ccedil;&atilde;o a objeto oferecido pela linguagem. Com ele &eacute; poss&iacute;vel declarar e acessar espa&ccedil;os de nomes, e tamb&eacute;m declarar classes e acessar objetos.</p>&#10;<p>O C++ define que alguns dos operadores podem ser sobrecarregados, o que permite, assim como na sobrecarga de fun&ccedil;&otilde;es, que diferentes tipos de dados sejam passados para um operador de forma a produzir diferentes resultados. Essa t&eacute;cnica tamb&eacute;m permite que <a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">classes</a> definidas por utilizadores tamb&eacute;m possam usufruir de operadores pr&oacute;prios, tornando poss&iacute;vel que uma classe <i>Lista</i> possa sobrecarregar o operador de ap&ecirc;ndice <code>+=</code> para que diversos elementos possam ser adicionados a lista, como elementos ou outras listas. Alguns operadores de classes definidas pelo utilizador devem ser obrigatoriamente sobrecarregados (definidos) a fim de poderem ser utilizados pela <a href="http://en.wikipedia.org/wiki/STL" id="w">STL</a>. Por exemplo, uma classe <i>Funcionario</i> deve fornecer o operador <i>menor que</i> (<code>&#60&semi;</code>) para ser utilizada pela fun&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_(computa%C3%A7%C3%A3o)" id="w">ordena&ccedil;&atilde;o</a> (<code>sort</code>). De acordo com o padr&atilde;o atual da linguagem, este requerimento &eacute; impl&iacute;cito <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">durante a compila&ccedil;&atilde;o</a>: caso a fun&ccedil;&atilde;o <code>sort</code> seja invocada para a um container da classe Funcionario e esta n&atilde;o define o operador <code>&#60&semi;</code>, h&aacute; erro de compila&ccedil;&atilde;o. Para padr&otilde;es futuros planeja&shy;se introduzir os &#34&semi;conceitos&#34&semi;, que auxiliaram a programa&ccedil;&atilde;o gen&eacute;rica na especifica&ccedil;&atilde;o dos requerimentos de um tipo de dado para que ele seja usado em uma fun&ccedil;&atilde;o. Por exemplo, os iteradores passados para <code>sort</code> estar&atilde;o associados ao conceito &#34&semi;tipo de dado compar&aacute;vel&#34&semi;, isto &eacute;, um tipo de dado que declara o operador <code>&#60&semi;</code>. Ao explicitar essa rela&ccedil;&atilde;o o c&oacute;digo se torna mais consistente, e o compilador &eacute; auxiliado a fim de retornar uma mensagem de erro mais adequada ao utilizador caso haja problemas durante a compila&ccedil;&atilde;o.</p>&#10;<a id="Pr%C3%A9&shy;processador" name="Pr%C3%A9&shy;processador"></a><h3> Pr&eacute;&shy;processador </h3>&#10;<p> &#10;O C++ &eacute; compilado em tr&ecirc;s fases: pr&eacute;&shy;processamento, compila&ccedil;&atilde;o propriamente dita (tradu&ccedil;&atilde;o para <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_objeto" id="w">c&oacute;digo objeto</a>) e liga&ccedil;&atilde;o.<sup id="_ref&shy;16" class="reference"><a href="#_note&shy;16" title="">[16]</a></sup><sup id="_ref&shy;17" class="reference"><a href="#_note&shy;17" title="">[17]</a></sup> Durante a primeira fase, as diretivas de pr&eacute;&shy;processamento s&atilde;o aplicadas atrav&eacute;s de <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_l%C3%A9xica" id="w">transforma&ccedil;&otilde;es l&eacute;xicas</a> no pr&oacute;prio c&oacute;digo fonte, que ent&atilde;o alimenta as pr&oacute;ximas fases de compila&ccedil;&atilde;o. Elas s&atilde;o identificadas no c&oacute;digo atrav&eacute;s do <a href="http://en.wikipedia.org/wiki/Caractere" id="w">caractere</a> <code>#</code>. O pr&eacute;&shy;processamento &eacute; utilizado para substituir partes de c&oacute;digo, para inutilizar partes de c&oacute;digo e para importar m&oacute;dulos externos.</p>&#10;<p>Por exemplo, o c&oacute;digo <code>#define PI 3.1415926535897932384626433</code> far&aacute; com que sempre que <code>PI</code> aparecer no c&oacute;digo, este ser&aacute; substitu&iacute;do por <code>3.1415926535897932384626433</code> e isso ocorre antes de come&ccedil;ar a compilar, &eacute; como se o usu&aacute;rio tivesse digitado o valor de <code>PI</code> ao inv&eacute;s do texto <code>PI</code>. Outro uso do pr&eacute;&shy;processador &eacute; o que segue: <code>#include &#60&semi;iostream&#62&semi;</code> far&aacute; com que seja inclu&iacute;do (importado) todo o conte&uacute;do da cabe&ccedil;alho <code>iostream</code> da biblioteca libc.</p>&#10;<a id="Gabaritos" name="Gabaritos"></a><h3> Gabaritos </h3>&#10;<p>Os gabaritos s&atilde;o diferentes de <a href="http://en.wikipedia.org/wiki/Macro" id="w">macros de programa&ccedil;&atilde;o</a> (que tamb&eacute;m podem ser usadas em C++, um artif&iacute;cio herdado do C): enquanto ambas as facilidades podem ser utilizadas para produzir c&oacute;digo em <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a>, gabaritos n&atilde;o restringem&shy;se &agrave; <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_l%C3%A9xica" id="w">substitui&ccedil;&otilde;es l&eacute;xicas</a>. Eles possuem conhecimento da <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_sem%C3%A2ntica" id="w">sem&acirc;ntica</a> e do sistema de <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipagem</a> da linguagem, e s&atilde;o utilizados principalmente para <a href="http://en.wikipedia.org/wiki/Polimorfismo" id="w">polimorfismo</a> est&aacute;tico (ver exemplo <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B#Polimorfismo est&aacute;tico" id="w">em anexo</a>) e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_gen%C3%A9rica" id="w">programa&ccedil;&atilde;o gen&eacute;rica</a>. Um gabarito tamb&eacute;m &eacute; uma <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Turing" id="w">m&aacute;quina de Turing</a> completa.</p>&#10;<p>No campo de programa&ccedil;&atilde;o gen&eacute;rica, um tipo de dado parametrizado em C++ &eacute; chamado uma classe gabarito. Ela define atrav&eacute;s de par&acirc;metros como devem ser os tipos de dado internos utilizados ao instanciar o objeto. Dessa maneira &eacute; poss&iacute;vel codificar uma classe gen&eacute;rica <i>arranjo</i>, que ao ser instanciada pode tornar&shy;se um arranjo de <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_inteiro" id="w">n&uacute;meros inteiros</a> ou um arranjo de carros de corrida (desde que <i>carro de corrida</i> esteja definido no &acirc;mbito da instancializa&ccedil;&atilde;o).</p>&#10;<a id="Objetos" name="Objetos"></a><h3> Objetos </h3>&#10;<p> &#10;O C++ introduziu alguns conceitos de <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orienta&ccedil;&atilde;o a objetos</a> ao C, como exemplificado pelas <a href="http://en.wikipedia.org/wiki/Classe" id="w">classes</a>, que apresentam quatro caracter&iacute;sticas comumente presentes em linguagens de programa&ccedil;&atilde;o orientadas a objeto: <a href="http://en.wikipedia.org/wiki/Abstra%C3%A7%C3%A3o" id="w">abstra&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Encapsulamento" id="w">encapsulamento</a>, <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a" id="w">heran&ccedil;a</a> e <a href="http://en.wikipedia.org/wiki/Polimorfismo" id="w">polimorfismo</a>. Cada vez que uma classe &eacute; instanciada &eacute; criado um objeto na <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">mem&oacute;ria</a>, que &eacute; basicamente um conjunto de atributos e opera&ccedil;&otilde;es reunidos.</p>&#10;<a id="Encapsulamento" name="Encapsulamento"></a><h4> Encapsulamento </h4>&#10;<p> &#10;O <a href="http://en.wikipedia.org/wiki/Encapsulamento" id="w">encapsulamento</a> permite que os atributos de classes possam ser declarados como p&uacute;blicos, privados ou protegidos. Um atributo p&uacute;blico (o menos restrito) pode ser acessado a partir de qualquer m&eacute;todo que tenha acesso ao objeto. Um atributo privado (o mais restrito) s&oacute; pode ser acessado por m&eacute;todos da pr&oacute;pria classe e por m&eacute;todos explicitamente declarados como permitidos para tal (utilizando a palavra reservada <code>friend</code>). Atributos protegidos s&oacute; podem ser acessados por m&eacute;todos da mesma classe, por m&eacute;todos de classes herdadas e por m&eacute;todos explicitamente declarados (utilizando a palavra reservada <code>friend</code>). &Eacute; considerado como uma boa pr&aacute;tica de programa&ccedil;&atilde;o restringir ao m&aacute;ximo o acesso aos atributos, de forma a isolar detalhes de implementa&ccedil;&atilde;o de uma classe, tornando p&uacute;blicas somente as fun&ccedil;&otilde;es membro que realizam uma <a href="http://en.wikipedia.org/wiki/Interface" id="w">interface</a> m&iacute;nima da classe com outros componentes.</p>&#10;<p>O isolamento dos dados proposto pelo encapsulamento n&atilde;o &eacute; infal&iacute;vel, podendo ser contornado ao realizar opera&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">baixo n&iacute;vel</a> em objetos. Dessa maneira, um atributo privado pode ser acessado e modificado a partir de um ponteiro para seu endere&ccedil;o de mem&oacute;ria sem problemas, ainda que isso seja considerado uma m&aacute; pr&aacute;tica de programa&ccedil;&atilde;o. Tal caracter&iacute;stica, herdada da linguagem C, &eacute; reflexo direto da liberdade que o C++ fornece ao desenvolvedor em rela&ccedil;&atilde;o a padr&otilde;es de projeto de software, cabendo a ele decidir qual &eacute; o mais adequado para seu <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a>. O desenvolvedor tanto pode esquecer tal caracter&iacute;stica, atendo&shy;se somente a detalhes de especifica&ccedil;&atilde;o em <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">alto n&iacute;vel</a>, quanto adequar tais caracter&iacute;sticas em sua especifica&ccedil;&atilde;o de forma mais baixo n&iacute;vel, visando desempenho ou algum outro objetivo.</p>&#10;<a id="Heran%C3%A7a" name="Heran%C3%A7a"></a><h4> Heran&ccedil;a </h4>&#10;<p> &#10;A <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a" id="w">heran&ccedil;a</a> de uma classe para com outra pode ser declarada como p&uacute;blica, protegida ou privada. Isso determina o qu&atilde;o relacionadas as classes ser&atilde;o entre si. Somente a heran&ccedil;a p&uacute;blica corresponde ao conceito usual de heran&ccedil;a, pois permite acesso total aos atributos da classe&shy;base. Entretanto, pode&shy;se tamb&eacute;m declarar heran&ccedil;as protegidas e privadas, com caracter&iacute;sticas parecidas como as detalhadas anteriormente sobre encapsulamento. Essa funcionalidade adicionou ao C++ a possibilidade de cria&ccedil;&atilde;o de classes abstratas, que n&atilde;o podem ser instanciadas, mas que oferecem interfaces de funcionamento para suas respectivas classes herdadas. Ela &eacute; um princ&iacute;pio b&aacute;sico da <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objeto" id="w">orienta&ccedil;&atilde;o a objeto</a> para a reutiliza&ccedil;&atilde;o de c&oacute;digo, pois permite que classes (possivelmente escritas por outros desenvolvedores e ent&atilde;o n&atilde;o modific&aacute;veis) possam ser herdadas de forma a ser incrementadas em funcionalidade.</p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a_m%C3%BAltipla" id="w">heran&ccedil;a m&uacute;ltipla</a> &eacute; uma das caracter&iacute;sticas do C++ mais controversas. Ela permite que uma classe possa ser derivada de mais de uma classe base, o que pode resultar em um complicado <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafo</a> de heran&ccedil;a e relacionamento entre classes. Por exemplo, uma classe <i>Gato voador</i> pode ser derivada tanto das classes <i>Gato</i> quanto <i>Mam&iacute;fero voador</i>. A mistura de heran&ccedil;as reflete em uma mistura de <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_nomes" id="w">espa&ccedil;os de nomes</a> na classe herdada, o que pode ser resolvido atrav&eacute;s da declara&ccedil;&atilde;o local de espa&ccedil;o de nomes, como explicado adiante.</p>&#10;<a id="Polimorfismo" name="Polimorfismo"></a><h3> Polimorfismo </h3>&#10;<p> &#10;Polimorfismo &eacute; a capacidade de usar um operador ou uma fun&ccedil;&atilde;o de diferentes maneiras, permitir fornecer diferentes significados de acordo com o contexto. Uma vez que um aplicativo &eacute; escrito utilizando o conceito de polimorfismo, pode ser facilmente estendido, oferecendo novos objetos que estejam em conformidade com a interface original. N&atilde;o &eacute; necess&aacute;rio recompilar programas originais, adicionando novos tipos. Apenas a re&shy;vincula&ccedil;&atilde;o &eacute; necess&aacute;ria para expor as novas mudan&ccedil;as juntamente com a antiga aplica&ccedil;&atilde;o. Ele auxilia na reutiliza&ccedil;&atilde;o de c&oacute;digo e contribui para a cria&ccedil;&atilde;o de aplica&ccedil;&otilde;es robustas. C++ suporta diversos tipos de <a href="http://en.wikipedia.org/wiki/Polimorfismo" id="w">polimorfismos</a>, sejam est&aacute;ticos (resolvidos em <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a> de c&oacute;digo) ou din&acirc;micos (resolvidos em <a href="http://en.wikipedia.org/wiki/Tempo_de_execu%C3%A7%C3%A3o" id="w">tempo de execu&ccedil;&atilde;o</a> de c&oacute;digo).</p>    &#10;<a id="Est%C3%A1tico" name="Est%C3%A1tico"></a><h4> Est&aacute;tico </h4>&#10;<p>A sobrecarga de fun&ccedil;&otilde;es &eacute; um polimorfismo est&aacute;tico que permite que um programa possa declarar v&aacute;rias fun&ccedil;&otilde;es com o mesmo nome, diferenciando entre si pela quantidade de par&acirc;metros apresentados e por seus respectivos tipos de dado. Assim, o mesmo nome de fun&ccedil;&atilde;o pode referir&shy;se a diferentes fun&ccedil;&otilde;es dependendo do contexto em que ela &eacute; usada. O tipo retornado pela fun&ccedil;&atilde;o n&atilde;o &eacute; utilizado para distinguir fun&ccedil;&otilde;es sobrecarregadas. A sobrecarga de operadores tamb&eacute;m &eacute; um polimorfismo est&aacute;tico que permite que a defini&ccedil;&atilde;o de certos operadores resultem em uma chamada de fun&ccedil;&atilde;o que depende dos tipos de dado dos operadores sendo utilizados.</p>&#10;<p>O C++ tamb&eacute;m suporta argumentos padr&atilde;o para os parametros das fun&ccedil;&otilde;es, o que permite omitir tal par&acirc;metro na invoca&ccedil;&atilde;o da fun&ccedil;&atilde;o. Quando uma fun&ccedil;&atilde;o &eacute; chamada com menos argumentos que o esperado e os argumentos expl&iacute;citos s&atilde;o compat&iacute;veis com os par&acirc;metros da esquerda &agrave; direita, os &uacute;ltimos par&acirc;metros s&atilde;o atribu&iacute;dos de acordo com o argumento padr&atilde;o. Semanticamente parecida com a sobrecarga de fun&ccedil;&otilde;es, essa t&eacute;cnica permite simplificar situa&ccedil;&otilde;es em que uma fun&ccedil;&atilde;o &eacute; declarada somente para invocar uma sobrecarga dela pr&oacute;pria com algum par&acirc;metro especificado.</p>&#10;<p>O C++ implementa polimorfismo param&eacute;trico atrav&eacute;s de gabaritos, que fazem o compilador gere uma inst&acirc;ncia separada da classe ou fun&ccedil;&atilde;o usada como gabarito para cada permuta&ccedil;&atilde;o de par&acirc;metros de tipo usado com ele, o que pode levar a dificultar a depura&ccedil;&atilde;o de c&oacute;digo. Um benef&iacute;cio que os gabaritos C++ t&ecirc;m sobre Java e C&#9839; &eacute; permitir a metaprograma&ccedil;&atilde;o por gabaritos, uma forma de pr&eacute;&shy;avalia&ccedil;&atilde;o de parte do c&oacute;digo em tempo de compila&ccedil;&atilde;o ao inv&eacute;s de tempo de execu&ccedil;&atilde;o.</p>&#10;<p>Os gabaritos em C++ fornecem um mecanismo sofisticado para a cria&ccedil;&atilde;o de c&oacute;digo gen&eacute;rico polim&oacute;rfico. Em particular, por meio da t&eacute;cnica <i>Curiously Recurring Template Pattern</i> &eacute; poss&iacute;vel implementar uma forma de polimorfismo est&aacute;tico que imita a sintaxe para substituir as fun&ccedil;&otilde;es virtuais. Uma vez que gabaritos s&atilde;o sens&iacute;veis aos tipos de dados e tamb&eacute;m s&atilde;o <a href="http://en.wikipedia.org/wiki/Turing_completa" id="w">Turing completos</a>, tamb&eacute;m podem ser usados para permitir que o compilador resolva condicionais recursivas e gerar programas substanciais atrav&eacute;s de metaprograma&ccedil;&atilde;o por gabaritos.</p>    &#10;<p>Entre os usos de polimorfismo est&aacute;tico, inclui&shy;se fun&ccedil;&otilde;es com o mesmo nome mas que tratam de diferentes par&acirc;metros, como <code>soma(int, int)</code> e <code>soma(double, double)</code> (o que, entretanto, ignora as facilidades dos gabaritos.) Tamb&eacute;m, vers&otilde;es novas da mesma fun&ccedil;&atilde;o que recebem par&acirc;metros adicionais, como <code>ExportarDados(void* buffer, int tamanho)</code> e <code>ExportarDados(void* buffer, int tamanho, unsigned long opcoes)</code>. Mais um uso &eacute; um mesmo nome de m&eacute;todo para atribuir ou obter o valor de uma propriedade, como <code>Classe::Propriedade(int x)</code> e <code>int x Class::Property() const</code>.</p>&#10;<a id="Din%C3%A2mico" name="Din%C3%A2mico"></a><h4> Din&acirc;mico </h4>&#10;<p>O polimorfismo por heran&ccedil;a &eacute; um exemplo de polimorfismo din&acirc;mico no qual <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiros</a> de uma classe base podem referenciar objetos de classes derivadas, o que permite que uma chamada de fun&ccedil;&atilde;o virtual seja resolvida em tempo de execu&ccedil;&atilde;o de c&oacute;digo. Ponteiros e refer&ecirc;ncias de uma classe base podem referenciar <a href="http://en.wikipedia.org/wiki/Objeto" id="w">objetos</a> de qualquer classe derivada de si, o que permite que <a href="http://en.wikipedia.org/wiki/Arranjo" id="w">arranjos</a> e outros containers de um dado tipo possam armazenar ponteiros de diversos tipos de dados, o que n&atilde;o poderia ser feito de outra maneira em C++. Como n&atilde;o &eacute; poss&iacute;vel descobrir se a convers&atilde;o do tipo base para o tipo derivado &eacute; segura em tempo de compila&ccedil;&atilde;o, a verifica&ccedil;&atilde;o deve ser feita durante a execu&ccedil;&atilde;o do c&oacute;digo. Para isso &eacute; fornecido o operador <code>dynamic_cast</code>, que permite tentar a convers&atilde;o segura de uma classe mais abstrata (classe base) para outra mais espec&iacute;fica (classe derivada). Para sua utiliza&ccedil;&atilde;o a linguagem disp&otilde;e do <a href="http://en.wikipedia.org/wiki/RTTI" id="w">RTTI</a>, uma t&eacute;cnica para manter em mem&oacute;ria informa&ccedil;&otilde;es sobre o <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipo de dado</a> de objetos. Caso a convers&atilde;o n&atilde;o seja poss&iacute;vel uma exce&ccedil;&atilde;o espec&iacute;fica &eacute; lan&ccedil;ada.</p>&#10;<p>Normalmente, quando uma fun&ccedil;&atilde;o em uma classe derivada substitui uma fun&ccedil;&atilde;o em uma classe base, a fun&ccedil;&atilde;o chamada &eacute; determinada pelo tipo do objeto. Uma dada fun&ccedil;&atilde;o &eacute; sobrescrita quando n&atilde;o existe nenhuma diferen&ccedil;a no n&uacute;mero ou tipo de par&acirc;metros, entre duas ou mais defini&ccedil;&otilde;es para aquela fun&ccedil;&atilde;o. Assim, em tempo de compila&ccedil;&atilde;o pode n&atilde;o ser poss&iacute;vel determinar o tipo do objeto e, portanto, a fun&ccedil;&atilde;o a ser chamada, tendo apenas um ponteiro de classe base, a decis&atilde;o &eacute; adiada at&eacute; o tempo de execu&ccedil;&atilde;o. Isso &eacute; chamado de despache din&acirc;mico. Fun&ccedil;&otilde;es ou m&eacute;todos virtuais permitem a implementa&ccedil;&atilde;o mais espec&iacute;fica da fun&ccedil;&atilde;o a ser chamada, de acordo com o tipo do objeto em tempo real. Em C++, isto &eacute; geralmente feito usando tabelas de fun&ccedil;&otilde;es virtuais. Se o tipo de objeto &eacute; conhecido, isso pode ser contornado, antecipando o nome da classe antes da chamada de fun&ccedil;&atilde;o, mas, em geral chamadas de fun&ccedil;&otilde;es virtuais s&atilde;o resolvidas em tempo de execu&ccedil;&atilde;o.</p>&#10;<p>Al&eacute;m das fun&ccedil;&otilde;es de membro padr&atilde;o, sobrecargas do operador e destrutores podem ser virtuais. A regra geral &eacute; que, se todas as fun&ccedil;&otilde;es da classe s&atilde;o virtuais, o destrutor tamb&eacute;m deve ser assim. Como o tipo de cria&ccedil;&atilde;o de um objeto &eacute; conhecido em tempo de compila&ccedil;&atilde;o, construtores de c&oacute;pia e de extens&atilde;o, n&atilde;o pode ser virtuais. No entanto pode acontecer de uma c&oacute;pia de um objeto ser criado quando um ponteiro para um objeto derivado &eacute; passado como um ponteiro para um objeto base. Nesse caso, uma solu&ccedil;&atilde;o comum &eacute; criar um clone() (ou similar) e declarar que a fun&ccedil;&atilde;o como virtual. O m&eacute;todo clone() cria e retorna uma c&oacute;pia da classe quando chamado.</p>&#10;<p>Um membro da fun&ccedil;&atilde;o tamb&eacute;m pode ser declarado puramente virtual, acrescentando <code>= 0</code> ap&oacute;s o par&ecirc;ntese de fechamento e antes do ponto e v&iacute;rgula. Os objetos n&atilde;o podem ser criados de uma classe com uma fun&ccedil;&atilde;o virtual pura e s&atilde;o chamados de tipos de dados abstratos. Esses tipos de dados abstratos s&oacute; podem ser derivados. Qualquer classe derivada herda a fun&ccedil;&atilde;o virtual pura deve apresentar uma defini&ccedil;&atilde;o n&atilde;o&shy;pura (e todas as outras fun&ccedil;&otilde;es virtuais puras), antes de objetos da classe derivada poderem ser criados.</p>&#10;<a id="Regra_dos_tr%C3%AAs" name="Regra_dos_tr%C3%AAs"></a><h4> Regra dos tr&ecirc;s </h4>&#10;<p>Uma regra informal no desenvolvimento orientado a objeto em C++ clama que se uma classe ou estrutura possui um dos seguintes itens, ela provavelmente deveria ter todos os tr&ecirc;s:<sup id="_ref&shy;18" class="reference"><a href="#_note&shy;18" title="">[18]</a></sup> destrutor, construtor de c&oacute;pia e operador de atribui&ccedil;&atilde;o (<code>=</code>).</p>&#10;<p>Esse tr&ecirc;s m&eacute;todos s&atilde;o fun&ccedil;&otilde;es membros especiais criadas pelo <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> automaticamente se n&atilde;o s&atilde;o definidas pelo desenvolvedor.<sup id="_ref&shy;19" class="reference"><a href="#_note&shy;19" title="">[19]</a></sup> Se um desses m&eacute;todos &eacute; definido explicitamente pelo desenvolvedor, isso significa que a vers&atilde;o gerada pelo compilador n&atilde;o serve para um dos casos, e portanto muito provavelmente tamb&eacute;m n&atilde;o serve para os outros casos.</p>&#10;<p>Um adendo a essa regra diz respeito &agrave; t&eacute;cnica <i><a href="http://en.wikipedia.org/wiki/RAII" id="w">RAII</a></i>:<sup id="_ref&shy;RAII_a" class="reference"><a href="#_note&shy;RAII" title="">[20]</a></sup> se ela for usada ent&atilde;o o destrutor pode ser deixado sem defini&ccedil;&atilde;o (tamb&eacute;m conhecida como &#34&semi;regra dos dois&#34&semi;<sup id="_ref&shy;21" class="reference"><a href="#_note&shy;21" title="">[21]</a></sup>).</p>&#10;<a id="Tratamento_de_exce%C3%A7%C3%B5es" name="Tratamento_de_exce%C3%A7%C3%B5es"></a><h3> Tratamento de exce&ccedil;&otilde;es </h3>&#10;<p> &#10;O tratamento de exce&ccedil;&atilde;o &eacute; um mecanismo desenvolvido para lidar com a ocorr&ecirc;ncia de algumas condi&ccedil;&otilde;es (chamadas exce&ccedil;&otilde;es) que alteram o funcionamento normal do fluxo de um programa de computador. O C++ suporta tal tratamento, de forma que o estado atual de um programa ap&oacute;s uma exce&ccedil;&atilde;o &eacute; alterado automaticamente para outro estado pr&eacute;&shy;definido para a recupera&ccedil;&atilde;o do sistema.</p>&#10;<p>Para isso foram adicionadas &agrave; linguagem as <a href="http://en.wikipedia.org/wiki/Palavra_reservada" id="w">palavras reservadas</a> <code>try</code> e <code>catch</code>. A primeira especifica um bloco de c&oacute;digo que ser&aacute; vigiado em rela&ccedil;&atilde;o &agrave; exce&ccedil;&otilde;es, de forma que se uma for identificada, o fluxo de programa ser&aacute; desviado para um bloco especificado pela segunda palavra reservada. Para um dado bloco <code>try</code> podem existir diversos blocos <code>catch</code>, capturando exce&ccedil;&otilde;es de diferentes tipos de dado. Alternativamente, a sintaxe <code>catch(&hellip;)</code> foi introduzida para especificar um bloco de tratamento de exce&ccedil;&atilde;o independente do tipo da exce&ccedil;&atilde;o, gen&eacute;rico.</p>&#10;<p>O conceito puro da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> para tratamento de exce&ccedil;&otilde;es ainda inclui o bloco de instru&ccedil;&otilde;es <code>finally</code>, que indica um bloco de c&oacute;digo executado ap&oacute;s um bloco <code>try</code> caso nenhuma exce&ccedil;&atilde;o tenha sido lan&ccedil;ada, indicando sucesso na opera&ccedil;&atilde;o. Tal abordagem n&atilde;o foi adicionada ao C++, sendo substitu&iacute;vel por outras t&eacute;cnicas como <i><a href="http://en.wikipedia.org/wiki/RAII" id="w">RAII</a></i><sup id="_ref&shy;RAII_b" class="reference"><a href="#_note&shy;RAII" title="">[20]</a></sup><sup id="_ref&shy;22" class="reference"><a href="#_note&shy;22" title="">[22]</a></sup>. De qualquer forma, &eacute; poss&iacute;vel que essa funcionalidade seja adicionada na pr&oacute;xima especifica&ccedil;&atilde;o da linguagem.</p>&#10;<a id="Espa%C3%A7o_de_nomes" name="Espa%C3%A7o_de_nomes"></a><h3> Espa&ccedil;o de nomes </h3>&#10;<p> &#10;O C++ introduziu os espa&ccedil;os de nomes para a organiza&ccedil;&atilde;o das <a href="http://en.wikipedia.org/wiki/Biblioteca_(computa%C3%A7%C3%A3o)" id="w">bibliotecas</a>, e sua fun&ccedil;&atilde;o &eacute; agrupar um contexto para identificadores (vari&aacute;veis, fun&ccedil;&otilde;es, classes, estruturas, entre outros). No contexto de <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistemas operativos</a>, o espa&ccedil;o de nomes poderia ser representado por <a href="http://en.wikipedia.org/wiki/Diret%C3%B3rio" id="w">diret&oacute;rios</a>. Toda a biblioteca padr&atilde;o est&aacute; contida no espa&ccedil;o de nomes <code>std</code> (abrevia&ccedil;&atilde;o de <i>standard</i>, que em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a> significa <i>padr&atilde;o</i>). Para utilizar um espa&ccedil;o de nomes pode ser feita tanto uma declara&ccedil;&atilde;o global dos espa&ccedil;os quanto local. Uma declara&ccedil;&atilde;o global &eacute; normalmente inserida no in&iacute;cio dos m&oacute;dulos, ap&oacute;s a importa&ccedil;&atilde;o dos m&oacute;dulos externos, utilizando a palavra reservada <code>using</code> (como em <code>using namespace std&semi;</code>, ver exemplo contextualizado <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B#Utilizando a biblioteca padr&atilde;o" id="w">em anexo</a>). Ela tamb&eacute;m pode ser usada em um &acirc;mbito pr&eacute;&shy;determinado por um bloco de c&oacute;digo. Uma declara&ccedil;&atilde;o local &eacute; inserida antes de invocar o identificador envolvido, utilizando o operador de resolu&ccedil;&atilde;o de &acirc;mbito <code>::</code> (como em <code>std::cout</code>, ver exemplo contextualizado <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B#Ol&aacute; mundo" id="w">em anexo</a>). A declara&ccedil;&atilde;o global &eacute; &uacute;til para reduzir a quantidade de c&oacute;digo produzido, sub entendendo a origem dos identificadores utilizados em todo um &acirc;mbito. Apesar disso, ela deixa margem &agrave; ambiguidades, pois &eacute; poss&iacute;vel que um mesmo identificador esteja presente em mais de um espa&ccedil;o de nome importado no m&oacute;dulo. Para eliminar esse problema deve&shy;se, al&eacute;m de utilizar a declara&ccedil;&atilde;o global, declarar o identificador amb&iacute;guo localmente cada vez que ele for utilizado.</p>&#10;<p>Em determinadas ocasi&otilde;es, espa&ccedil;os de nome n&atilde;o considerados durante a primeira verifica&ccedil;&atilde;o do espa&ccedil;o de nomes de uma fun&ccedil;&atilde;o podem tamb&eacute;m ser utilizados na busca, dependendo dos tipos de dados utilizados nos argumentos. A t&eacute;cnica, chamada <i>busca de nomes dependente de argumento</i> ou <i>Koening lookup</i>, ocorre quando a busca expl&iacute;cita pela fun&ccedil;&atilde;o n&atilde;o encontra correspondente, come&ccedil;ando ent&atilde;o a procurar por espa&ccedil;os de nomes associados. Um padr&atilde;o muito utilizado pela <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">Standard Template Library</a> &eacute; declarar sobrecarga de operadores que somente s&atilde;o encontrados pelo compilador atrav&eacute;s dessa t&eacute;cnica.</p>&#10;<a id="Ponteiros_e_refer%C3%AAncias" name="Ponteiros_e_refer%C3%AAncias"></a><h3> Ponteiros e refer&ecirc;ncias </h3>&#10;<p> &#10; &#10;O C++ herdou a funcionalidade de ponteiros do C e toda a aritm&eacute;tica de ponteiros dispon&iacute;vel para aquela linguagem: tratando um ponteiro como um <a href="http://en.wikipedia.org/wiki/Inteiro_(tipo_de_dado)" id="w">tipo inteiro</a> &eacute; poss&iacute;vel mover&shy;se facilmente por regi&otilde;es de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">mem&oacute;ria</a>. A inst&acirc;ncia de um ponteiro em C++ &eacute; uma <a href="http://en.wikipedia.org/wiki/Vari%C3%A1vel_(programa%C3%A7%C3%A3o)" id="w">vari&aacute;vel</a> que armazena um <a href="http://en.wikipedia.org/wiki/Endere%C3%A7o_de_mem%C3%B3ria" id="w">endere&ccedil;o de mem&oacute;ria</a>, e que pode ser <a href="http://en.wikipedia.org/wiki/Null_(programa%C3%A7%C3%A3o)" id="w">nula</a>. A <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">biblioteca padr&atilde;o</a> ainda fornece <code>auto_ptr</code>, uma esp&eacute;cie de <a href="http://en.wikipedia.org/wiki/Ponteiro_inteligente" id="w">ponteiro inteligente</a> para contagem de refer&ecirc;ncias que pode ser utilizado em algumas situa&ccedil;&otilde;es como uma alternativa segura aos ponteiros primitivos do C, automatizando o processo de desaloca&ccedil;&atilde;o de mem&oacute;ria do objeto apontado pelo ponteiro.</p>&#10;<p>Por quest&otilde;es de seguran&ccedil;a, o C++ introduziu tamb&eacute;m o tipo de dado refer&ecirc;ncia, um tipo mais restrito de ponteiro. Uma refer&ecirc;ncia definida para outro objeto n&atilde;o pode ser mais referenciada, qualquer ocorr&ecirc;ncia do nome no c&oacute;digo diz respeito ao objeto referenciado. Como consequ&ecirc;ncia, n&atilde;o &eacute; poss&iacute;vel realizar &#34&semi;aritm&eacute;tica de refer&ecirc;ncias&#34&semi;. Outra consequ&ecirc;ncia &eacute; que n&atilde;o &eacute; poss&iacute;vel alterar uma refer&ecirc;ncia para que ela defina outro objeto&semi; ap&oacute;s definida, essa rela&ccedil;&atilde;o vale para todo o tempo de vida. Em contrapartida, um mesmo ponteiro frequentemente aponta para diferentes &aacute;reas de mem&oacute;ria.</p>&#10;<p>Apesar de teoricamente poss&iacute;vel<sup id="_ref&shy;23" class="reference"><a href="#_note&shy;23" title="">[23]</a></sup>, a exist&ecirc;ncia de refer&ecirc;ncias nulas n&atilde;o &eacute; considerada, podendo&shy;se assumir que uma refer&ecirc;ncia sempre indica um objeto v&aacute;lido em mem&oacute;ria.</p>&#10;<a id="Incompatibilidade_com_C" name="Incompatibilidade_com_C"></a><h3> Incompatibilidade com C </h3>&#10;<p>&Eacute; incorreto considerar o C++ como um super conjunto de C, isto &eacute;, uma linguagem que implementa o C completamente e que adiciona novas funcionalidades.<sup id="_ref&shy;24" class="reference"><a href="#_note&shy;24" title="">[24]</a></sup> Grande parte de c&oacute;digo C pode ser perfeitamente compilado em C++, mas existem algumas pequenas diferen&ccedil;as sint&aacute;ticas e sem&acirc;nticas entre as linguagens que tornam alguns trechos de c&oacute;digo C v&aacute;lidos em c&oacute;digo C++ inv&aacute;lido, ou c&oacute;digos que exibem comportamentos diferentes em cada linguagem.<sup id="_ref&shy;incompatibilidade_a" class="reference"><a href="#_note&shy;incompatibilidade" title="">[25]</a></sup></p>&#10;<p>Talvez a diferen&ccedil;a mais comum &eacute; que C permite a convers&atilde;o impl&iacute;cita entre o <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipo de dado</a> <code>void*</code> para <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiros</a> para outros tipos, algo que o C++ n&atilde;o permite. Logo, o seguinte c&oacute;digo em C &eacute; v&aacute;lido:</p>&#10;<p />&#10;&#10;<p>Para assegurar&shy;se que o c&oacute;digo funcione tanto em C quanto C++ &eacute; necess&aacute;rio explicitar a convers&atilde;o, acrescentando o que &eacute; chamado de &#34&semi;cast&#34&semi;:</p>&#10;<p />&#10;&#10;<p>Outra quest&atilde;o de <a href="http://en.wikipedia.org/wiki/Portabilidade_(inform%C3%A1tica)" id="w">portabilidade</a> entre as linguagens &eacute; o fato do C++ adicionar v&aacute;rias novas palavras reservadas, como <code>new</code> e <code>class</code>, que podem ser utilizadas como identificadores (por exemplo nomes de vari&aacute;veis) em C, gerando incompatibilidade.</p>&#10;<p>Algumas outras incompatibilidades foram removidas no padr&atilde;o C99, que agora suporta facilidades como coment&aacute;rios por <i><code>//</code></i>.<sup id="_ref&shy;incompatibilidade_b" class="reference"><a href="#_note&shy;incompatibilidade" title="">[25]</a></sup> Tanto C99 quanto C++ definem o tipo de dado <code>bool</code> e suas respectivas constantes <code>true</code> e <code>false</code>. Apesar disso, enquanto a defini&ccedil;&atilde;o no C++ &eacute; embarcada na pr&oacute;pria linguagem, tornando tais elementos palavras reservadas, em C tais identificadores s&atilde;o declarados atrav&eacute;s da biblioteca padr&atilde;o <code>stdbool.h</code>.</p>&#10;<p>Algumas constru&ccedil;&otilde;es sint&aacute;ticas s&atilde;o v&aacute;lidas tanto em C quanto C++, mas produzem resultado diferente. Por exemplo, o valor literal <code>&#39&semi;a&#39&semi;</code> possui tipo de dado <code>int</code> em C e <code>char</code> em C++, o que significa que uma chamada <code>sizeof(&#39&semi;a&#39&semi;)</code>, que retorna a quantidade de bytes ocupada pelo identificador, pode resultar em resultados diferentes entre as duas linguagens. Na pr&aacute;tica, esse exemplo espec&iacute;fico n&atilde;o &eacute; realmente um problema j&aacute; que caracteres literais s&atilde;o convertidos para o tipo <code>int</code> implicitamente pelo compilador tanto em C quanto em C++.</p>&#10;<a id="An%C3%A1lise_sint%C3%A1tica_do_c%C3%B3digo_fonte" name="An%C3%A1lise_sint%C3%A1tica_do_c%C3%B3digo_fonte"></a><h3> An&aacute;lise sint&aacute;tica do c&oacute;digo fonte </h3>&#10;<p>Como a <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_formal" id="w">gram&aacute;tica</a> C++ &eacute; bastante complexa, &eacute; dif&iacute;cil construir um bom <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_sint%C3%A1tica_(computa%C3%A7%C3%A3o)" id="w">analisador sint&aacute;tico</a> para <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> C++ utilizando algoritmos cl&aacute;ssicos como o <a href="http://en.wikipedia.org/wiki/Analisador_sint%C3%A1tico_LALR" id="w">LALR(1)</a>.<sup id="_ref&shy;parsingCPP_a" class="reference"><a href="#_note&shy;parsingCPP" title="">[26]</a></sup> Por exemplo, com o LALR &eacute; poss&iacute;vel analisar c&oacute;digo <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a>.<sup id="_ref&shy;27" class="reference"><a href="#_note&shy;27" title="">[27]</a></sup> A flexibilidade da linguagem tamb&eacute;m &eacute; fruto de ambiguidades que um analisador simples n&atilde;o consegue distinguir. Por esse motivo, existem poucas ferramentas para an&aacute;lise e transforma&ccedil;&atilde;o n&atilde;o trivial de c&oacute;digo, como <a href="http://en.wikipedia.org/wiki/Refatora%C3%A7%C3%A3o" id="w">refatora&ccedil;&atilde;o</a>. Em suas primeiras especifica&ccedil;&otilde;es o C++ era uma gram&aacute;tica LALR, entretanto, com a adi&ccedil;&atilde;o de funcionalidades como espa&ccedil;o de nomes, exce&ccedil;&otilde;es, gabaritos e o tipo bool, essa caracter&iacute;stica logo se tornou inv&aacute;lida.<sup id="_ref&shy;parsingCPP_b" class="reference"><a href="#_note&shy;parsingCPP" title="">[26]</a></sup></p>&#10;<p>A an&aacute;lise sint&aacute;tica n&atilde;o &eacute; a tarefa mais dif&iacute;cil na constru&ccedil;&atilde;o de uma ferramenta C++. Outras tarefas incluem entender o significado dos identificadores do programa que um <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> deve possuir. Sistemas pr&aacute;ticos de processamento n&atilde;o devem somente analisar o c&oacute;digo fonte, mas tamb&eacute;m compreender exatamente cada identificador em diferentes usos, lidando com as regras de &acirc;mbito de identificadores (ver um c&oacute;digo contextualizado <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B#Ambiguidade da linguagem" id="w">em anexo</a>).</p>&#10;<p>O grupo <a href="http://en.wikipedia.org/wiki/Biblioteca_Boost" id="w">Boost</a> possui um projeto para a constru&ccedil;&atilde;o de um analisador sint&aacute;tico C++ com base na biblioteca Spirit,<sup id="_ref&shy;28" class="reference"><a href="#_note&shy;28" title="">[28]</a></sup> de forma que se torna um m&eacute;todo padr&atilde;o e <a href="http://en.wikipedia.org/wiki/Software_livre" id="w">livre</a> de an&aacute;lise sint&aacute;tica para a linguagem.</p>&#10;<a id="Exemplos_de_c%C3%B3digo" name="Exemplos_de_c%C3%B3digo"></a><h2> Exemplos de c&oacute;digo </h2>&#10;<p> </p>&#10;<p>Exemplo de um programa que imprime na tela &#34&semi;Ol&aacute;, Mundo!&#34&semi;.</p>&#10;<p />&#10;&#10;<a id="Cr%C3%ADticas" name="Cr%C3%ADticas"></a><h2> Cr&iacute;ticas </h2>&#10;<p> &#10; </p>&#10;<p>A cita&ccedil;&atilde;o de Stroutrup trata com humor o fato de o C++, ao possibilitar a <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">programa&ccedil;&atilde;o de alto n&iacute;vel</a>, ter facilitado a codifica&ccedil;&atilde;o de algoritmos e organiza&ccedil;&atilde;o de projetos em rela&ccedil;&atilde;o ao C, uma linguagem que requer constante aten&ccedil;&atilde;o contra erros l&oacute;gicos de programa&ccedil;&atilde;o devido &agrave; sua alta flexibidade. Por outro lado, o C++ possui nuances da sintaxe e sem&acirc;ntica da linguagem muito sutis, dif&iacute;ceis de serem identificados, e que quando n&atilde;o percebidos podem levar a comportamentos indesejados no c&oacute;digo.</p>&#10;<p>Pontos positivos do C++ incluem a produ&ccedil;&atilde;o de c&oacute;digo o quanto mais eficiente poss&iacute;vel, fazendo uso de otimiza&ccedil;&otilde;es agressivas e sofisticadas dos compiladores. Entretanto, a linguagem ainda mantem alta flexibilidade, <a href="http://en.wikipedia.org/wiki/Portabilidade_(inform%C3%A1tica)" id="w">portabilidade</a> e consist&ecirc;ncia. Um exemplo da flexibilidade &eacute; a possibilidade de programa&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">alto</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">baixo n&iacute;vel</a>. Outro exemplo &eacute; a possibilidade de metaprograma&ccedil;&atilde;o e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_gen%C3%A9rica" id="w">programa&ccedil;&atilde;o gen&eacute;rica</a>. Mais um ponto positivo &eacute; ampla disponibilidade e suporte, devido principalmente &agrave; grande base de desenvolvedores. Al&eacute;m disso, a compatilidade com C, resultando em vasta base de c&oacute;digo. Fora do lado t&eacute;cnico, um positivo &eacute; que a linguagem n&atilde;o est&aacute; sob o dom&iacute;nio duma empresa (em contraste do <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_Java" id="w">Java</a> &mdash; <a href="http://en.wikipedia.org/wiki/Sun_Microsystems" id="w">Sun Microsystems</a> (atualmente pertencente a Oracle Corporation) ou <a href="http://en.wikipedia.org/wiki/Visual_Basic" id="w">Visual Basic</a> &mdash; <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a>)&semi; a padroniza&ccedil;&atilde;o &eacute; responsabilidade da <a href="http://en.wikipedia.org/wiki/Organiza%C3%A7%C3%A3o_Internacional_para_Padroniza%C3%A7%C3%A3o" id="w">ISO</a>.</p>&#10;<p>Por outro lado, pontos negativos do C++ incluem grande per&iacute;odo para o aprendizado devido &agrave; complexidade da linguagem. Tamb&eacute;m, os <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a> atuais, que nem sempre produzem o c&oacute;digo mais otimizado, tanto em velocidade quanto tamanho do c&oacute;digo, e que geralmente produzem mensagens de erro dif&iacute;ceis de serem interpretadas em problemas relacionados com gabaritos. Ainda relacionado a aprendizado e uso, a <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">biblioteca padr&atilde;o</a> n&atilde;o cobre &aacute;reas importantes da programa&ccedil;&atilde;o, como <a href="http://en.wikipedia.org/wiki/Thread_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">threads</a> (suportada por C++11), conex&otilde;es <a href="http://en.wikipedia.org/wiki/TCP/IP" id="w">TCP/IP</a>, <a href="http://en.wikipedia.org/wiki/GUI" id="w">interface gr&aacute;fica</a> e manipula&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Sistema_de_ficheiros" id="w">sistemas de arquivos</a>, o que implica na necessidade de cria&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Biblioteca_de_rotinas" id="w">bibliotecas</a> pr&oacute;prias para tal, que pecam em <a href="http://en.wikipedia.org/wiki/Portabilidade_(inform%C3%A1tica)" id="w">portabilidade</a> e padroniza&ccedil;&atilde;o. Apesar da ampla base de c&oacute;digo legada do C, o C++ tamb&eacute;m herdou daquela linguagem problemas de entendimento de sintaxe do mesmo. Mais um ponto negativo &eacute; que devido &agrave; grande flexibilidade no desenvolvimento, &eacute; recomendado o uso de padr&otilde;es de programa&ccedil;&atilde;o mais amplamente que em outras linguagens.</p>&#10;<a id="Comunidade_de_desenvolvimento" name="Comunidade_de_desenvolvimento"></a><h2> Comunidade de desenvolvimento </h2>&#10;<a id="Pessoas_not%C3%A1veis" name="Pessoas_not%C3%A1veis"></a><h3> Pessoas not&aacute;veis </h3>&#10;<p>O desenvolvimento da linguagem C++ &eacute; fruto do trabalho de milhares de pessoas associadas &agrave; academia e &agrave; ind&uacute;stria de software, e pode consistir na utiliza&ccedil;&atilde;o da linguagem, em seu ensino, na constru&ccedil;&atilde;o de bibliotecas de rotinas ou na participa&ccedil;&atilde;o no comit&ecirc; de padroniza&ccedil;&atilde;o, entre outras atividades. Algumas pessoas tiveram participa&ccedil;&atilde;o fundamental durante a hist&oacute;ria para o desenvolvimento.<sup id="_ref&shy;29" class="reference"><a href="#_note&shy;29" title="">[29]</a></sup> Primeiramente, o pr&oacute;prio <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup" id="w">Bjarne Stroustrup</a>, criador da linguagem e de seu primeiro compilador.<sup id="_ref&shy;entrevista A&shy;Z_g" class="reference"><a href="#_note&shy;entrevista A&shy;Z" title="">[1]</a></sup> O cientista ainda participa na padroniza&ccedil;&atilde;o e divulga o C++ no meio acad&ecirc;mico. <a href="http://en.wikipedia.org/wiki/En:Andrew_Koenig_(programmer)" id="w">Andrew Koenig</a>  &eacute; outro pesquisador not&aacute;vel, bastante atuante na padroniza&ccedil;&atilde;o e creditado pela t&eacute;cnica <i>Koenig lookup</i> (demonstrada <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B#Busca de nomes dependente de argumento" id="w">em anexo</a>). J&aacute; <a href="http://en.wikipedia.org/wiki/Scott_Meyers" id="w">Scott Meyers</a> &eacute; um doutor em ci&ecirc;ncia da computa&ccedil;&atilde;o, e escritor de diversos livros sobre o desenvolvimento de software utilizando a linguagem. Assim como Meyers, <a href="http://en.wikipedia.org/wiki/Herb_Sutter" id="w">Herb Sutter</a> &eacute; escritor de diversos livros sobre C++ e centenas de colunas e artigos, e um not&aacute;vel pesquisador sobre <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_concorrente" id="w">programa&ccedil;&atilde;o concorrente</a> e <a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">multitarefa</a>. <a href="http://en.wikipedia.org/wiki/Andrei_Alexandrescu" id="w">Andrei Alexandrescu</a> &eacute; considerado um dos maiores especialistas em programa&ccedil;&atilde;o C++ avan&ccedil;ada. Na &aacute;rea de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_gen%C3%A9rica" id="w">programa&ccedil;&atilde;o gen&eacute;rica</a> destaca&shy;se o programador <a href="http://en.wikipedia.org/wiki/R%C3%BAssia" id="w">russo</a> <a href="http://en.wikipedia.org/wiki/Alexander_Stepanov" id="w">Alexander Stepanov</a>, a figura chave na cria&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">Standard Template Library</a>.</p>&#10;<a id="Bibilioteca_Boost" name="Bibilioteca_Boost"></a><h3> Bibilioteca Boost </h3>&#10;<p> &#10;Parte da comunidade de desenvolvimento do C++ foi respons&aacute;vel pela cria&ccedil;&atilde;o da Boost, um conjunto de <a href="http://en.wikipedia.org/wiki/Biblioteca_de_rotinas" id="w">bibliotecas</a> que estendem a funcionalidade da linguagem, mais especificamente, da <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">bibilioteca padr&atilde;o</a>. O processo de disponibiliza&ccedil;&atilde;o de bibliotecas da Boost &eacute; mais r&aacute;pido do que o do comit&ecirc; de padroniza&ccedil;&atilde;o da linguagem, e o projeto acaba servindo como uma forma de teste em campo das bibliotecas, que eventualmente podem ser migradas para a especifica&ccedil;&atilde;o da linguagem. Para o TR1 do C++0x, pelo menos dez bibliotecas j&aacute; foram aceitas.<sup id="_ref&shy;30" class="reference"><a href="#_note&shy;30" title="">[30]</a></sup> A base de usu&aacute;rios da Boost &eacute; grande, o que reflete no controle de qualidade. Funcionalidades oferecidas v&atilde;o desde bibliotecas gerais como <i><a href="http://en.wikipedia.org/wiki/Ponteiro_inteligente" id="w">smart_ptr</a></i><sup id="_ref&shy;31" class="reference"><a href="#_note&shy;31" title="">[31]</a></sup> a abstra&ccedil;&otilde;es do <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> como o <i><a href="http://en.wikipedia.org/wiki/Sistema_de_arquivos" id="w">filesystem</a></i><sup id="_ref&shy;32" class="reference"><a href="#_note&shy;32" title="">[32]</a></sup> a bibliotecas para usu&aacute;rios avan&ccedil;ados como a <i>MPL</i>.<sup id="_ref&shy;33" class="reference"><a href="#_note&shy;33" title="">[33]</a></sup></p>&#10;<a id="Ferramentas" name="Ferramentas"></a><h2> Ferramentas </h2>&#10;<a id="Ambientes_de_desenvolvimento" name="Ambientes_de_desenvolvimento"></a><h3> Ambientes de desenvolvimento </h3>&#10;<p>Abaixo &eacute; mostrada uma lista dos principais ambientes de desenvolvimento C++, sejam eles <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a> ou <a href="http://en.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado" id="w">ambientes de desenvolvimento integrado</a> (IDE).</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable" style="text&shy;align:center">&#10;<tr>&#10;<th>Nome</th>&#10;<th>Coment&aacute;rio</th>&#10;<th>Tipo de licen&ccedil;a</th>&#10;<th>&Eacute; <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a>?</th>&#10;<th>&Eacute; <a href="http://en.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado" id="w">IDE</a>?</th>&#10;<th>&Eacute; <a href="http://en.wikipedia.org/wiki/Depurador" id="w">depurador</a>?</th>&#10;<th>Plataformas</th></tr>&#10;<tr>&#10;<td>G++</td>&#10;<td style="text&shy;align:left">Um componente do <a href="http://en.wikipedia.org/wiki/GCC" id="w">GCC</a>, compilador padr&atilde;o do <a href="http://en.wikipedia.org/wiki/Projecto_GNU" id="w">Projecto GNU</a></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a>, <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a> e <a href="http://en.wikipedia.org/wiki/AmigaOS" id="w">AmigaOS</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Dev&shy;C%2B%2B" id="w">Dev&shy;C++</a></td>&#10;<td style="text&shy;align:left">IDE livre famosa entre iniciantes. Seu compilador &eacute; o <a href="http://en.wikipedia.org/wiki/MinGW" id="w">MinGW</a>, uma vers&atilde;o do G++ para Windows.</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a><sup id="_ref&shy;34" class="reference"><a href="#_note&shy;34" title="">[34]</a></sup></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Ultimate%2B%2B" id="w">Ultimate++</a></td>&#10;<td style="text&shy;align:left">U++ &eacute; um framework C++ multi&shy;plataforma, para desenvolvimento r&aacute;pido de aplica&ccedil;&otilde;es, focado na produtividade de programadores.</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a> e <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_C%2B%2B" id="w">Intel C++</a></td>&#10;<td style="text&shy;align:left">Produz c&oacute;digo otimizado para <a href="http://en.wikipedia.org/wiki/Processador" id="w">processadores</a> <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a></td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a> e <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Visual_C%2B%2B" id="w">Microsoft Visual C++</a></td>&#10;<td style="text&shy;align:left">&Eacute; o mais conhecido para a plataforma <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, com ferramentas e tecnologias auxiliares para desenvolvimento nessa plataforma (como <a href="http://en.wikipedia.org/wiki/Microsoft_Foundation_Classes" id="w">MFC</a>, <a href="http://en.wikipedia.org/wiki/Active_Template_Library" id="w">ATL</a>, <a href="http://en.wikipedia.org/wiki/Component_Object_Model" id="w">COM</a>, entre outras). Oferece ainda uma vers&atilde;o gratuita com restri&ccedil;&otilde;es de uso<sup id="_ref&shy;35" class="reference"><a href="#_note&shy;35" title="">[35]</a></sup></td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/C%2B%2B_Builder" id="w">C++ Builder</a></td>&#10;<td style="text&shy;align:left">Ferramenta da <a href="http://en.wikipedia.org/wiki/Embarcadero" id="w">Embarcadero</a> (anteriormente da <a href="http://en.wikipedia.org/wiki/Borland" id="w">Borland</a>), que compartilha a mesma <a href="http://en.wikipedia.org/wiki/IDE" id="w">IDE</a> do <a href="http://en.wikipedia.org/wiki/Delphi" id="w">Delphi</a> chamada de RAD Studio, sendo poss&iacute;vel a utiliza&ccedil;&atilde;o dos mesmos componentes visuais do Delphi (VCL) em um c&oacute;digo C++.</td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Qt_Creator" id="w">Qt Creator</a></td>&#10;<td style="text&shy;align:left">IDE especializada em (mas n&atilde;o restrita a) desenvolvimento na plataforma <a href="http://en.wikipedia.org/wiki/Qt" id="w">Qt</a>. Utiliza o <a href="http://en.wikipedia.org/wiki/G%2B%2B" id="w">g++</a> como compilador e o <a href="http://en.wikipedia.org/wiki/Gdb" id="w">gdb</a> como depurador (ou seus equivalentes para <a href="http://en.wikipedia.org/wiki/MinGW" id="w">MinGW</a> em Windows).</td>&#10;<td>Livre/Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a> e <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Open_Watcom" id="w">Open Watcom</a></td>&#10;<td style="text&shy;align:left">Suporta plataformas antigas, at&eacute; ent&atilde;o sem suporte completo &agrave; <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">biblioteca padr&atilde;o</a></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/DOS" id="w">DOS</a>, <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/OS/2" id="w">OS/2</a> e <a href="http://en.wikipedia.org/wiki/Netware" id="w">Netware</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Comeau_C%2B%2B" id="w">Comeau C++</a></td>&#10;<td style="text&shy;align:left">Pode ser experimentado pela <a href="http://en.wikipedia.org/wiki/Internet" id="w">Internet</a><sup id="_ref&shy;36" class="reference"><a href="#_note&shy;36" title="">[36]</a></sup></td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a> e <a href="http://en.wikipedia.org/wiki/Solaris" id="w">Solaris</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Turbo_C%2B%2B" id="w">Turbo C++</a></td>&#10;<td style="text&shy;align:left">Possui vers&atilde;o gratuita<sup id="_ref&shy;37" class="reference"><a href="#_note&shy;37" title="">[37]</a></sup> no s&iacute;tio oficial e tamb&eacute;m uma vers&atilde;o paga.<sup id="_ref&shy;38" class="reference"><a href="#_note&shy;38" title="">[38]</a></sup> &Eacute; similar ao <a href="http://en.wikipedia.org/wiki/C%2B%2B_Builder" id="w">C++ Builder</a>.</td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Eclipse_(IDE)" id="w">Eclipse</a></td>&#10;<td style="text&shy;align:left">Dispon&iacute;vel para C++ atrav&eacute;s da extens&atilde;o CDT.<sup id="_ref&shy;39" class="reference"><a href="#_note&shy;39" title="">[39]</a></sup></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/JVM" id="w">JVM</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/NetBeans" id="w">NetBeans</a></td>&#10;<td style="text&shy;align:left">Possui vers&atilde;o especializada para C++ e tamb&eacute;m dispon&iacute;vel atrav&eacute;s de um plugin.</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a>, <a href="http://en.wikipedia.org/wiki/JVM" id="w">JVM</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Anjuta" id="w">Anjuta</a></td>&#10;<td style="text&shy;align:left">Suporta muitas capacidades avan&ccedil;adas como gerenciamento de projetos e um poderoso editor de c&oacute;digo fonte. Uma nova vers&atilde;o do Anjuta (Anjuta 2.*) que integra o Glade est&aacute; em desenvolvimento ativo.</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Code::Blocks" id="w">Code::Blocks</a></td>&#10;<td style="text&shy;align:left">Ambiente aberto e multi&shy;plataforma, em sua vers&atilde;o para Windows utiliza o compilador MinGW, apesar de tamb&eacute;m suportar outros compiladores como o Visual C++, Digital Mars, Borland C++ 5.5 e Open Watcom.<sup id="_ref&shy;40" class="reference"><a href="#_note&shy;40" title="">[40]</a></sup></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Digital_Mars" id="w">Digital Mars</a></td>&#10;<td>Propriet&aacute;ria</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/DOS" id="w">DOS</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Codelite" id="w">Codelite</a></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Geany" id="w">Geany</a></td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/GNAT_Programming_Studio" id="w">GNAT Programming Studio</a></td>&#10;<td style="text&shy;align:left">Utiliza o compilador GCC</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, <a href="http://en.wikipedia.org/wiki/Solaris" id="w">Solaris</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/KDevelop" id="w">KDevelop</a></td>&#10;<td style="text&shy;align:left">Utiliza o compilador GCC</td>&#10;<td>Livre</td>&#10;<td> </td>&#10;<td> </td>&#10;<td> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a>, <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a></td></tr></table></div>&#10;&#10;<a id="Aplicativos_desenvolvidos_em_C%2B%2B" name="Aplicativos_desenvolvidos_em_C%2B%2B"></a><h3> Aplicativos desenvolvidos em C++ </h3>&#10;<p>Abaixo segue uma lista de exemplos de aplicativos parcial ou totalmente escritos em C++, de acordo com Bjarne Stroustrup, que n&atilde;o garante sua precis&atilde;o e veracidade, ainda que seja respons&aacute;vel por sua publica&ccedil;&atilde;o.<sup id="_ref&shy;41" class="reference"><a href="#_note&shy;41" title="">[41]</a></sup>&#10; &#10; &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Adobe_Acrobat" id="w">Adobe Acrobat</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Adobe_Illustrator" id="w">Adobe Illustrator</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Adobe_Photoshop" id="w">Adobe Photoshop</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Amazon" id="w">Amazon</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/BeOS" id="w">BeOS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Blender" id="w">Blender</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Common_Desktop_Environment" id="w">Common Desktop Environment</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Doom_III" id="w">Doom III</a> (<a href="http://en.wikipedia.org/wiki/Motor_de_jogo" id="w">motor de jogo</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/EMule" id="w">eMule</a></li>&#10;<li>Motores de busca <a href="http://en.wikipedia.org/wiki/Google" id="w">Google</a>, em especial <a href="http://en.wikipedia.org/wiki/Googlebot" id="w">Googlebot</a><sup id="_ref&shy;42" class="reference"><a href="#_note&shy;42" title="">[42]</a></sup></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Half&shy;Life_(s%C3%A9rie)" id="w">S&eacute;rie Half&shy;Life</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Internet_Explorer" id="w">Internet Explorer</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/IPod" id="w">iPod</a> (<a href="http://en.wikipedia.org/wiki/GUI" id="w">GUI</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/KDE" id="w">KDE</a> (<a href="http://en.wikipedia.org/wiki/Qt" id="w">Qt</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Lunar_Magic" id="w">Lunar Magic</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a></li></ul>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Maya" id="w">Maya</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mars_Pathfinder" id="w">Mars Pathfinder</a>, <a href="http://en.wikipedia.org/wiki/Opportunity" id="w">Opportunity</a> e outras <a href="http://en.wikipedia.org/wiki/Sonda_espacial" id="w">sondas</a> da <a href="http://en.wikipedia.org/wiki/NASA" id="w">NASA</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_Office" id="w">Microsoft Office</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio" id="w">Microsoft Visual Studio</a> (<a href="http://en.wikipedia.org/wiki/Visual_Basic" id="w">Visual Basic</a>, <a href="http://en.wikipedia.org/wiki/Visual_FoxPro" id="w">Visual FoxPro</a>, <a href="http://en.wikipedia.org/wiki/Visual_C%2B%2B" id="w">Visual C++</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_Windows" id="w">Microsoft Windows</a> (diversas vers&otilde;es)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mozilla_Firefox" id="w">Mozilla Firefox</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mozilla_Thunderbird" id="w">Mozilla Thunderbird</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MySQL" id="w">MySQL</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/M%C3%A1quina_virtual_Java" id="w">M&aacute;quina virtual Java</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/LibreOffice" id="w">LibreOffice</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Outlook_Express" id="w">Outlook Express</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/PCSX2" id="w">PCSX2</a> (Emulador de <a href="http://en.wikipedia.org/wiki/Playstation_2" id="w">Playstation 2</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/SETI%40home" id="w">SETI@home</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Symbian_OS" id="w">Symbian OS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Winamp" id="w">Winamp</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Tibia" id="w">Tibia</a></li></ul>&#10;<p>|}</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p> &#10; &#10; &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C%2B%2B" id="w">Biblioteca padr&atilde;o do C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Biblioteca_Boost" id="w">Biblioteca Boost</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Operadores_em_C_e_C%2B%2B" id="w">Operadores em C e C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">Orienta&ccedil;&atilde;o a objetos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">Standard Template Library</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%2B%2B" id="w">Anexo:Lista de exemplos de c&oacute;digo C++</a></li></ul>&#10;<p> &#10;</p>&#10;<div class="references&shy;small"><ol class="references">&#10;<li id="_note&shy;entrevista A&shy;Z">&uarr&semi; <a href="#_ref&shy;entrevista A&shy;Z_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_c" title=""><sup><i><b>c</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_d" title=""><sup><i><b>d</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_e" title=""><sup><i><b>e</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_f" title=""><sup><i><b>f</b></i></sup></a> <a href="#_ref&shy;entrevista A&shy;Z_g" title=""><sup><i><b>g</b></i></sup></a> </li><li id="_note&shy;2"><b><a href="#_ref&shy;2" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;3"><b><a href="#_ref&shy;3" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;4"><b><a href="#_ref&shy;4" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;5"><b><a href="#_ref&shy;5" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;STL">&uarr&semi; <a href="#_ref&shy;STL_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;STL_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;7"><b><a href="#_ref&shy;7" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;8"><b><a href="#_ref&shy;8" title="">&uarr&semi;</a></b> Uma discuss&atilde;o sobre o tema encontra&shy;se na se&ccedil;&atilde;o de incompatibilidades.</li><li id="_note&shy;9"><b><a href="#_ref&shy;9" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;10"><b><a href="#_ref&shy;10" title="">&uarr&semi;</a></b> Mais informa&ccedil;&otilde;es sobre o C++ ABI podem ser obtidas no  </li><li id="_note&shy;11"><b><a href="#_ref&shy;11" title="">&uarr&semi;</a></b> Um exemplo &eacute; o livro de Ivor Horton:&#10;<dl><dd> </dd></dl></li><li id="_note&shy;12"><b><a href="#_ref&shy;12" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;13"><b><a href="#_ref&shy;13" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;14"><b><a href="#_ref&shy;14" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;15"><b><a href="#_ref&shy;15" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;16"><b><a href="#_ref&shy;16" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;17"><b><a href="#_ref&shy;17" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;18"><b><a href="#_ref&shy;18" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;19"><b><a href="#_ref&shy;19" title="">&uarr&semi;</a></b> O construtor padr&atilde;o tamb&eacute;m &eacute; criado automaticamente pelo compilador caso o desenvolvedor n&atilde;o tenha definido nenhum outro construtor para a classe.</li><li id="_note&shy;RAII">&uarr&semi; <a href="#_ref&shy;RAII_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;RAII_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;21"><b><a href="#_ref&shy;21" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;22"><b><a href="#_ref&shy;22" title="">&uarr&semi;</a></b> Herb Sutter realiza uma compara&ccedil;&atilde;o entre as t&eacute;cnicas RAII e Dispose (que depende do conceito de <i>finally</i>) em seu blog pessoal:<br/> </li><li id="_note&shy;23"><b><a href="#_ref&shy;23" title="">&uarr&semi;</a></b> Dado um tipo de dado <code>T</code>, uma refer&ecirc;ncia pode ser definida para nulo atrav&eacute;s de <code>T&#38&semi; var = *(T*)0&semi;</code>. Notar entretanto que obter o conte&uacute;do de nulo resulta em <a href="http://en.wikipedia.org/wiki/Comportamento_indefinido" id="w">comportamento indefinido</a>, o que indica m&aacute; pr&aacute;tica de programa&ccedil;&atilde;o.</li><li id="_note&shy;24"><b><a href="#_ref&shy;24" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;incompatibilidade">&uarr&semi; <a href="#_ref&shy;incompatibilidade_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;incompatibilidade_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;parsingCPP">&uarr&semi; <a href="#_ref&shy;parsingCPP_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;parsingCPP_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;27"><b><a href="#_ref&shy;27" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;28"><b><a href="#_ref&shy;28" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;29"><b><a href="#_ref&shy;29" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;30"><b><a href="#_ref&shy;30" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;31"><b><a href="#_ref&shy;31" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;32"><b><a href="#_ref&shy;32" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;33"><b><a href="#_ref&shy;33" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;34"><b><a href="#_ref&shy;34" title="">&uarr&semi;</a></b> Uma <a class="externallink" href="http://freshmeat.net/projects/dev&shy;cpp" rel="nofollow" title="http://freshmeat.net/projects/dev&shy;cpp">vers&atilde;o para Linux</a> come&ccedil;ou a ser desenvolvida, mas foi abandonada em 2002</li><li id="_note&shy;35"><b><a href="#_ref&shy;35" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;36"><b><a href="#_ref&shy;36" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;37"><b><a href="#_ref&shy;37" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;38"><b><a href="#_ref&shy;38" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;39"><b><a href="#_ref&shy;39" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;40"><b><a href="#_ref&shy;40" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;41"><b><a href="#_ref&shy;41" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;42"><b><a href="#_ref&shy;42" title="">&uarr&semi;</a></b>  </li></ol></div>&#10;&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p><br/>&#10;Livro: Programa&ccedil;&atilde;o em C++ Builder 3, Autor: Roberto Falanga J&uacute;nior, Visual Books, Editora Catarinense de Inform&aacute;tica, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/8585943513" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/8585943513">ISBN 85&shy;85943&shy;51&shy;3</a>&#10;<br/></p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<dl><dt>Material de estudo</dt></dl>&#10;<ul>&#10;<li> </li>&#10;<li>  &mdash; <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> em C++</li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<dl><dt>Bibliotecas e reposit&oacute;rios de c&oacute;digo</dt></dl>&#10;<ul>&#10;<li>  &mdash; conjunto de <a href="http://en.wikipedia.org/wiki/Biblioteca_de_rotinas" id="w">bibliotecas</a> C++ revisadas por especialistas.</li>&#10;<li>  &mdash; reposit&oacute;rio de <a href="http://en.wikipedia.org/wiki/Software_livre" id="w">c&oacute;digo livre</a> C e C++</li>&#10;<li>  &mdash; classes fundamentais <a href="http://en.wikipedia.org/wiki/Portabilidade" id="w">port&aacute;veis</a> da <a href="http://en.wikipedia.org/wiki/GNU" id="w">GNU</a></li>&#10;<li>  &mdash; bibliotecas livres, compostas somente de cabe&ccedil;alhos, com o intuito de servir como extens&atilde;o &agrave; <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" id="w">STL</a></li>&#10;<li>  &mdash; refer&ecirc;ncias de C e C++</li></ul>&#10;<p> &#10; </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:C%2B%2B" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_orientadas_a_objetos" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o orientadas a objetos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_baseadas_em_classes" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o baseadas em classes</a></p></body></html>